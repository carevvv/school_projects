

***Наследование*** - механизм, с помощью которого один объект (производного класса) приобретает свойства другого объекта (родительского, базового класса). 

**Наследование** позволяет объекту производного класса наследовать от своего родителя общие **атрибуты**, а для себя определять только те характеристики, которые делают его уникальным внутри **класса**.

Производный **класс** конкретизирует, в общем случае расширяет базовый класс. Наследование поддерживает концепцию **иерархической** классификации. 

Новый класс не обязательно описывать, начиная с нуля, что существенно упрощает работу программиста.


## Единичное наследование

==Конструкторы, деструкторы и operator= не наследуются!!!==

[image.png](photo/20241108115957.png)

- Для классов наследование по умолчанию — private 
- Для структур наследование по умолчанию — public 

- При создании объекта из derived-cl сначала вызывается конструктор base-cl , затем собственный конструктор. 
- При уничтожении объекта из derived-cl сначала вызывается собственный деструктор, затем деструктор base-cl .

	Использование **списка инициализации** – единственный способ вызвать конструктор base-cl с параметрами при создании объекта из derived-cl.

```
struct A { 
	int x;
	A (int y) { x = y; } 
};

struct B : A {
	int z;
	B (int n = 0) : A(n) { z = n; } 
}
```
	 Список инициализации позволяет задавать параметры для базовых классов, когда происходит инициализация производного класса. Это необходимо для правильного инициализирования наследуемых объектов.
```
// Базовый класс
class Point {
public:
    Point(int x, int y)
        : x_(x), y_(y) /
    {

private:
    int x_; 
    int y_; 
};
class ColoredPoint : public Point {
public:
    ColoredPoint(int x, int y, const std::string& color)
        : Point(x, y), color_(color)
    {
}
private:
    std::string color_; 
};
```


### Public наследование

```
   - Члены public, остаются public.
   - Члены protected остаются protected.
   - Члены private не могут быть доступны(но могут быть доступны через методы базового класса).
```

### Protected наследование

```
   - Члены public и protected становятся protected.
   - Члены private
```

### Private наследование

```
   - Все члены становятся private.
```


### Примеры единичного наследования

```
struct A { int x; int y; }; 
struct B : A { int z; };
class C : protected A { int z; };

A * pa;
B b; C c, * pc = &c;
b.x = 1; pc -> z; // ошибка: доступ к закрытому полю
b.y = 2; pc -> x; // ошибка: доступ к защищённому полю
b.z = 3; pa = ( A * ) pc;
a = b; pa -> x; // правильно: поле A::x – открытое
```

### Сокрытие имён

```
struct A {
	int f ( int x , int y);
	int g ();
	int h;
};
struct B : public A {
	int x;
	void f ( int x );
	void h ( int x );
};

A a, *pa;
B b, *pb;
pb = &b;
pb -> f (1); // вызывается B::f(1)
pb -> g (); // вызывается A::g()
pb -> h = 1; // Err.! функция h(int) – не L-value выражение
pa = pb;
pa -> f (1); // Err.! функция A::f(1) имеет 2 параметра
```


### Видимость - Доступность имён

```
using namespace std;
int x; // Глобальная переменная

// Глобальная функция
void f(int a) { 
    cout << "::f " << a << endl; 
}

class A {
    int x; // Закрытый член класса A
public:
    void f(int a) { 
        cout << "A::f " << a << endl; 
    }
};

class B : public A {
public:
    void f(int a) { 
        cout << "B::f " << a << endl; 
    }
    
    void g();
};

void B::g() {
    f(1);        // Вызов B::f(1)
    A::f(1);    // Вызов A::f(1)
    ::f(1);     // Вызов глобальной void f(int)
    
    // x = 2;   // Ошибка!!! – осуществляется доступ к закрытому члену класса A
}
```

### Вызов конструкторов базового и производного классов
```
#include <iostream>
using namespace std;

class A {...};

class B : public A {
public:
    B();
    B(const B &);
};

class C : public A {
public:
    // Нет явно описанного конструктора копирования
};

int main() {
    B b1;           // A (), B ()
    B b2 = b1;     // A (), B (const B &)
    
    C c1;          // A (), C ()
    C c2 = c1;     // A (const A &), C (const C &)
    
    return 0;
}

```


## Виртуальные методы

Виртуальная функция - функция, использующиеся для достижения **полиморфизма**, позволяющая производным классам переопределять поведение этой функции. 

```
class Base {
   public:
       virtual void show() {
           cout << "Base show()" << endl;
       }
};

class Derived : public Base {
   public:
       void show() override { // переопределение
           cout << "Derived show()" << endl;
       }
};

```

##### Таблица виртуальных функций (vtable):
- Это структура данных, которая содержит указатели на виртуальные функции для каждого класса, который имеет виртуальные функции. Когда вызывается виртуальная функция, компилятор использует vtable для поиска нужного метода в зависимости от типа объекта.


##### Указатель на базовый класс:
- Когда вы работаете с указателями или ссылками на базовый класс, вы можете вызвать виртуальные функции производных классов, если такие имеются. Это дает возможность динамически вызывать правильные методы в зависимости от фактического типа на этапе выполнения.
```
Base* b = new Derived();
b->show(); // Выведет "Derived show()"
```

##### Абстрактный класс:
- Класс, содержащий хотя бы одну чистую виртуальную функцию. Абстрактные классы предназначены для наследования.

##### Чистая виртуальная функция:
- Функция, предназначенная только для наследования(нельзя определить)
```
class AbstractBase {
public:
   virtual void show() = 0; // чистая виртуальная функция
};
```

##### Деструкторы и виртуальные функции:
- Если хотя бы одна функция класса является виртуальной, то рекомендуется также сделать деструктор виртуальным. Это гарантирует, что вызывается правильный деструктор для производных классов при удалении объектов через указатели на базовые классы.

##### Полиморфный классм
- Класс называется полиморфным, если содержит хотя бы один виртуальный метод. 
- Объект полиморфного класса называют полиморфным объектом.



#### Механизм виртуальных функций (механизм динамического полиморфизма)

1. Виртуальность функции, описанной с использованием
служебного слова **virtual** не работает сама по себе, она
начинает работать, когда появляется класс, производный от
данного, с функцией с таким же прототипом.

2. Виртуальные функции выбираются по типу объекта, на который
ссылается указатель (или ссылка) на базовый класс.

3. У виртуальных функций должны быть одинаковые прототипы.
Исключение составляют функции с одинаковым именем и
списком формальных параметров, у которых тип результата есть
указатель или ссылка на себя (т.е. соответственно на базовый и
производный класс).

4. Если виртуальные функции отличаются только типом результата
(кроме случая выше), генерируется ошибка.

5. Для виртуальных функций, описанных с использованием
служебного слова virtual, с разными прототипами работает
механизм сокрытия имен.

#### Реализация виртуальных функций 

• Для каждого полиморфного класса создается таблица указателей на его виртуальные методы — **vtbl** — массив, индекс элемента которого соответствует прототипу виртуальной функции класса, а содержимое — ее адресу.

• В каждый объект полиморфного класса в public-область неявно помещается указатель на его vtbl — **vtbl*** * pvtbl;

• При вызове виртуального метода используется механизм косвенных вызовов: this — адрес объекта, по значению поля **pvtbl** по этому адресу находится таблица vtbl, по прототипу выбранной функции определяется индекс элемента таблицы, а затем по адресу, указанному в таблице вызывается функция.

• Для производного полиморфного класса vtbl строится по таблице базового класса, в которой производится замещение адресов тех виртуальных функций, прототипы которых совпали с прототипами виртуальных функций базового класса. Адреса новых виртуальных функций производного класса добавляются в конец его **vtbl**.

### Интерфейсы 

- **Интерфейсами** - абстрактные классы, которые не содержат нестатических полей-данных, и все их методы являются открытыми чистыми виртуальными функциями.

[первый скрин](photo/20241111233124.png)
[второй скрин](photo/20241111233146.png)


#### Пример 1.

```
class X {
public:
    void g() {
        cout << "X::g\n";
    }
    
    virtual void f() {
        g(); // вызов на объекте Y
        h(); // вызов на объекте Y
    }
    
    virtual void h() {
        cout << "X::h\n";
    }
};

class Y : public X {
public:
    void g() {
        cout << "Y::g\n";
    }
    
    virtual void f() {
        g(); // вызов здесь будет Y::g
        h(); // вызов на объекте Y
    }
    
    virtual void h() {
        cout << "Y::h\n";
    }
};


int main() {
    Y b;
    X *px = &b;
    px->f(); // Y::g Y::h Y::h
    px->g(); // X::g Y::h
    return 0;
}

```



## Множественное наследование

Множественное наследование происходит, когда подкласс имеет два или более суперкласса

```
#include <iostream>
using namespace std;

class Computer {
    private:
        void turn_on() {
            cout << "Computer is on." << endl;
        }
};

class Monitor {
    public:
        void turn_on() {
            cout << "Monitor is on." << endl;
        }
};

class Laptop: public Computer, public Monitor {};

int main() {
    Laptop Laptop_instance;
    // Laptop_instance.turn_on();
    // will cause compile time error
    return 0;
}
```

### Проблема ромба

```
class L { public: int n; ... };
class A : public L { ... }; 
class B : public L { ... }; 
class C : public A, public B { ... void f (); ... };
```

[скрин](photo/20241112004246.png)
#### О доступе к членам производного класса
```
void C::f () { ... n = 5; ...} // Er.! – неясно, чье n,
но void С::f () { ...A::n = 5; ...} // O.K.! , либо B::n = 5;
```
Имя класса в операции разрешения видимости (А или В) – это указание, в каком классе в решетке смежности искать заданное имя.

#### О преобразовании указателей

Указатель на объект производного класса может быть неявно преобразован к указателю на объект базового класса, только если этот базовый класс является однозначным и доступным(доступ к нему можно получить только через А или только через B и он publiс)

```
void g ( ) {
	C* pc = new C;
	L* pl = pc; // Er.! – L не является однозначным,
	pl = (L*) pc; // Er.! – явное преобразование не помогает,
	// но возможно:
	pl = (L*) (А*) pc; // либо pl = (L*) (В*) pc; O.K.! 
}
```


На этапе разработки ее можно разрешить следующим образом:
- вызвать метод конкретного суперкласса;
- обратиться к объекту подкласса как к объекту определенного суперкласса;
- переопределить проблематичный метод в последнем дочернем классе (в коде — `turn_on()` в подклассе `Laptop`).

## Виртуальные базовые классы.

```
class L { public: int n ; ... };
class A : virtual public L { ... };
class B : virtual public L { ... }; 
class C : public A, public B { ... void f (); ... };
```

[скрин](photo/20241112004714.png)

теперь доступно:
```
void C :: f () { ... n = 5; ...} // О.К.! – n в одном экземпляре

void g () {
	С* pс = new С;
	L* pl = pc; // O.K.! – появилась однозначность.
}
```

### Правила выбора имен в производном классе.

```
1 шаг: контроль однозначности (т.е. проверяется, определено ли анализируемое имя в одном базовом классе или в нескольких); при этом контекст не привлекается, совместное использование (в одном из базовых классов) допускается. 

2 шаг: если однозначно определенное имя есть имя перегруженной функции, то пытаются разрешить анализируемый вызов (т.е. найти best-maching).

3 шаг: если предыдущие шаги завершились успешно, то проводится контроль доступа.
```

### Неоднозначность из-за совпадающих имен в различных базовых классах

[скрин](photo/20241112005059.png)


## Статические члены класса.

Статические переменные обычно применяются для хранения значений, специфичных для класса, для всех объектов класса в целом. То есть статические поля хранят состояние всего класса. Статическая переменная определяется только один раз и будет существовать, даже если объекты класса не были созданы.


• Статические члены-данные и члены-функции описываются в классе с
квалификатором static.

• Статические члены-данные существуют в одном экземпляре и
доступны для всех объектов данного класса.

• Статические члены класса существуют независимо от конкретных
экземпляров класса, поэтому обращаться к ним можно еще до
размещения в памяти первого объекта этого класса, а также изменять,
используя, например, имя константного объекта класса.

• Необходимо предусмотреть выделение памяти под каждый
статический член-данное класса (т.е. описать его вне класса с возможной
инициализацией), т.к. при описании самого класса или его экземпляров
память под статические члены-данные не выделяется.

• Доступ к статическим членам класса (наряду с обычным способом)
можно осуществлять через имя класса (без указания имени
соответствующего экземпляра) и оператор разрешения области
видимости «::».

```
class A {
	public:
	static int x;
	static void f (char c);
};
int A::x; // !!! – размещение статического объекта в памяти
void g() {
	A::x = 10;
	A::f ('a');
}
```

#### Особенности использования статических методов класса 

• Статические методы класса используются, в основном, для работы с глобальными объектами или статическими полями данных соответствующего класса. 

• Статические методы класса не могут пользоваться нестатическими членами класса.

• Статические методы класса не могут пользоваться указателем this , т.е. использовать объект, от имени которого происходит обращение к функции.

• Статические методы класса не могут быть виртуальными и константными (inline - могут)
