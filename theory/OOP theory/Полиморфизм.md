

***Полиморфизм*** - механизм, позволяющий использовать один и тот же **интерфейс** для общего класса действий. В общем случае концепция полиморфизма выражается с помощью фразы «один **интерфейс** — много методов». 

Выбор конкретного действия (метода) применительно к конкретной ситуации возлагается на компилятор. Программисту же достаточно запомнить и применять один **интерфейс**, вместо нескольких, что также упрощает его работу. 

##### Различаются следующие виды полиморфизма: 
- статический (на этапе компиляции, с помощью перегрузки функций), 
- динамический (во время выполнения программы, реализуется с помощью виртуальных функций)
- параметрический (на этапе компиляции, с использованием механизма шаблонов).

-----
### 1. Статический полиморфизм

Статический полиморфизм разрешается на этапе компиляции. Компилятор определяет, какую именно функцию или метод вызвать в зависимости от типов аргументов. Основные механизмы статического полиморфизма в C++:

- Перегрузка функций
- Перегрузка операторов

-----
### 2. Динамический полиморфизм

Динамический полиморфизм реализуется с помощью наследования и виртуальных функций. В этом случае выбор вызываемой функции происходит во время выполнения программы.

--------------------------------------------------------------------------

### Перегрузка операторов

Для перегрузки встроенных операций С++ используется ключевое слово ``operator.


Перегружать операцию можно с помощью 
	• метода класса,
	• внешней функции, в частности, функции друга (что менее эффективно).


==Нельзя перегружать: «.», «::», «?:», «.*», sizeof, и typeid !!!==

Пример

```
class complex {
	double re, im;
	public:
		complex (double r = 0, double i = 0) { 
		re = r;
		im = i;
}

complex operator+ (const complex & a) {
	complex temp (re + a.re, im + a.im);
	return temp;
} 

operator double () { 
	return re; – функция преобразования
} 
};

int main () {
	complex x (1, 2), y (5, 8), z;
	double t = 7.5;
	z = x + y; // O.K. – найс
	z = z + t; // O.K. – найс
	z = t + x; // Er.! – err
}
```

==в любом случае сохраняется приоритет, ассоциативность и местность операций!!!==

операции  = , [ ] , ( ) и -> можно перегрузить только нестатическими методами класса, что гарантирует, что первым операндом будет сам объект, к которому операция применяется!!!


###### Особенности перегрузки операций ++ и --:
	префиксная : ++ x; `~ x.operator ++ ();
	постфиксная : x ++; `~ x.operator ++ (0);


###### Перегрузка операции ->

Операцию -> перегружают методом класса, объекты которого играют роль «умных» указателей на объекты другого класса.

Метод operator->() обязан возвращать либо указатель, либо объект класса, для которого также перегружена операция ->

###### Пример перегрузки операции «( )» и операции вывода «<<»

```
const double & operator () (int i, int j) const {
	return M [ i ] [ j ];
}
double & operator () (int i, int j) { 
	return M [ i ] [ j ]; 
}
friend ostream & operator << (ostream & s, const Matrix & a) {
	for (int i = 0; i < 3 ; i ++) {
			for (int j = 0; j < 3; j ++)
				s << a (i, j) << ' ';
		s << endl;
	}
	return s;
}
```

### Перегрузка функций

О перегрузке можно говорить только для функций из одной области видимости!

Позволяет иметь несколько функций с одинаковым именем, но разными параметрами. Компилятор выбирает нужную функцию на основе типов и количества аргументов.

##### Алгоритм поиска и выбора функции:

1. Выбираются только те перегруженные функции, для которых фактические параметры соответствуют формальным по количеству и типу.

2. Для каждого параметра функции строится множество функций, оптимально отождествляемых по этому параметру.

3. Находится пересечение этих множеств:
	• если это ровно одна функция – она и является
	искомой,
	• если множество пусто или содержит более одной
	функции, генерируется сообщение об ошибке.

Отождествление функции(2 шаг):

	а) Точное отождествление. 
	б) Отождествление при помощи расширений. 
	в) Отождествление с помощью стандартных преобразований. 
	г) Отождествление с помощью преобразований, определенных пользователем. 
	д) Отождествление по ... .


##### 1. Точное отождествление
- Что делает: Проверяет, соответствуют ли типы параметров фактических и формальных параметров функции полностью (попадание по типу, включая квалификаторы, такие как const и volatile).

##### 2. Отождествление при помощи расширений
- Что делает: Использует расширение типов для поиска подходящих функций. Например, если есть функция, принимающая int, а фактический параметр — long, может быть выполнено автоматическое расширение типа int до long.

```
void f (int); void g () {
	short aa = 1; 
	float ff = 1.0; 
	void f (double);
	f (ff); // f (double) \
	f (aa); // f (int) 
}
```
##### 3. Отождествление с помощью стандартных преобразований
- Что делает: Применяет стандартные преобразования типов, такие как преобразование к int (double до int), преобразования указателей (например, из базового класса к производному) и преобразования с помощью std::initializer_list.
```
void f (char);
void f (double); 

void g () { ... f (0); // неоднозначность, т.к. // преобр. int → char и // int → double равноправны }
```

##### 4. Отождествление с помощью преобразований, определенных пользователем
- Что делает: Позволяет использовать пользовательские преобразования типов, например, через конструкторы или операторы преобразования, определенные классами.
```
struct S { 
	S (long); // long → S
	operator int (); // S → int ... 
};

void g (S);
void g (char*);

void ex (S &a) {
	g (1); // O.K. g ( S ( (long) 1) ); т.е. g (S) — на шаге г) 
	g (0); // O.K. g ( (char*) 0); т.е. g (char*) — на шаге в)!!!
```

##### 5. Отождествление по ...

```
class Real {
	public:
		Real (double);
...
};

void f (int, Real);
void f (int, ...); // можно и без «,»

void g () {
	f (1, 1); // O.K. f (int, Real);
	f (1, "Anna"); // O.K. f (int, ...);
}
```
#### Примеры перегрузок

```
1. void f (int);
2. void f (int &);

int main () {
	int i = 1;
	int ri & = i;
	// f(i); // Err.! Неоднозначность выбора функции
	// f(ri); // Err.! Неоднозначность выбора функции
	f(1); // O.K.!
	return 0;
}

```

```
1. void f (int &); 
2. void f (const int &); 
3. void f (const char &);

int main () {
	int i = 1; 
	const int ci = 2; 
	char c = 'a'; 
	f(i); // 1.
	f(ci); // 2.
	f(c); // 3.
	return 0; 
}
```

```
1. void f (int );
2. void f (const int );

int main () {
	int i = 1;
	const int ci = 2;
	// f(i); // Err.! Неоднозначность выбора функции
	// f(ci); // Err.! Неоднозначность выбора функции
	return 0;
}
```
----
### 3. Параметрический полиморфизм

Параметрический полиморфизм позволяет писать код, который может работать с любым типом данных. В C++ это достигается с помощью шаблонов

- Шаблон представляет собой предварительное описание функции или класса, конкретное представление которых зависит от параметров шаблона.
- Для описания шаблонов используется ключевое слово template, вслед за которым указываются аргументы (параметры шаблона), заключенные в угловые скобки.
- Параметры шаблона перечисляются через запятую, и могут быть: а) именами типов (перед именем типа надо указывать ключевое слово class или typename). б) объектами следующих типов: - целочисленного, - перечислимого, - указательного (в том числе указатели на члены класса), - ссылочного;
- Параметры-объекты являются константами, их нельзя изменять внутри шаблона.

Пример: функция суммирования элементов типа Т массива размера size
```
template < class T >
T sum ( T array[ ], int size ) {
	T res = 0;
	for ( int i = 0; i < size; i++ ) res += array[ i ];
		return res;
}

int iarray [10];
int i_sum = sum < int > ( iarray, 10 );
```
Пример с заданным размером:
```
template < class T, int size >
T sum ( T array [ ] ) { 
	/* ... */
}

i_sum = sum < int, 10 > ( iarray );
```

Ошибки при выборе параметров:
```
template < class T >
T max (T & x, T & y) {
	return x > y ? x : y;
}

int main ( ) {
	double x = 1.5, y = 2.8, z;
	int i = 5, j = 12, k;
	char * s1 = "abft";
	char * s2 = "abxde", * s3;
	z = max ( x, y ); // max <double>
	k = max < int > (i, j); // max <int>
	//z = max (x, i); // Err! - неоднозначный выбор параметров
	z = max < double > ( y, j );
	s3 = max (s2, s1); // max < char * >,
	// но происходит сравнение адресов
	return 0;
}
```

#### Алгоритм выбора оптимально отождествляемой функции с учетом шаблонов

➢ Для каждого шаблона, подходящего по набору формальных параметров
функции, осуществляется формирование перегруженной функции,
соответствующей списку фактических параметров шаблона.

➢ Если есть два шаблона функции и один из них более специализирован (т.е.
каждый его допустимый набор фактических параметров также соответствует
и второй специализации ), то далее рассматривается только он.

➢ Осуществляется поиск оптимально отождествляемой функции из
полученного набора функций, включая определения обычных функций,
подходящие по количеству и типу параметров. При этом если параметры
некоторого шаблона функции были определены путем выведения по типам
фактических параметров вызова функции, то при дальнейшем поиске
оптимально отождествляемой функции к параметрам данной специализации
шаблона нельзя применять никаких описанных выше преобразований, кроме
преобразований Точного отождествления.

➢ Если обычная функция и специализация подходят одинаково хорошо, то
выбирается обычная функция.

➢ Если полученное множество подходящих вариантов состоит из одной
функции, то вызов разрешим. Если множество пусто или содержит более
одной функции, то генерируется сообщение об ошибке.

### Шаблоны классов.

-  Шаблоны создаются для классов, имеющих общую логику работы.

-  Для шаблонов класса никакие фактические параметры по умолчанию не выводятся. 

-  Функции-члены класса-шаблона автоматически становятся функциями шаблонами.

- В C++ необходимо явно указывать шаблонные параметры перед каждым определением функции шаблонного класса. Это позволяет компилятору понять, что это определение связано с шаблонным классом и какими шаблонными параметрами оно управляется.

```
template <class T, int max_size >
class stack {
	T s [max_size];
	int top;
	public:
		stack ( ) { top = 0;}
		void reset ( ) { top = 0;}
		void push (T i);
		T pop () ;
		bool is_empty ( ) { return top == 0;}
		bool is_full () { return top == max_size;}
};

template <class T, int max_size >
T stack <T, max_size > :: pop ( ) {
	if ( ! is_empty () ) {
		top --;
		return s [top];
	}
	else
		throw
			"stack_is_empty";
}

```