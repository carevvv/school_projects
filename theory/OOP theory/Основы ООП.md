# ООП

Абстракция — центральное понятие ООП, позволяющая программисту справиться со сложностями решаемых им задач.

Основные механизмы (постулаты) ООП:
• инкапсуляция,
• наследование,
• полиморфизм.

#### Декомпозиция задачи

***Декомпозиция*** – научный метод, использующий структуру задачи и позволяющий разбить решение одной большой задачи на решения серии меньших задач, возможно взаимосвязанных, но более простых.

#####  Объектно-ориентированная декомпозиция задачи 

***Объектно-ориентированная декомпозиция*** – выделение элементов, принадлежащих различным абстракциям проблемной области (вычленение объектов проблемной области и определение их свойств).

Пример: студент, ВУЗ, стек

###### **Принципы:**
1. Выделяемые элементы не следует делать слишком мелкими.
2. При выделении элементов представлять их в виде черного ящика, внутренне устройство которого неизвестно, но определены выполняемые им действия и важные для внешнего использования «входы» и «выходы» (интерфейс выделенного элемента).
3. Компоненты, в рамках одного выделенного элемента должны быть концептуально взаимосвязаны. 
4. Их интерфейс следует стремиться минимизировать.

#### Синтаксис класса

```
class имя_класса {
[private] : закрытые члены класса (функции, типы и поля-данные)
[public] : открытые члены класса (функции, типы и поля-данные) 
[protected] : protected: защищенные члены класса } 
список_объектов;
```

**Отличие структур от классов в C++(только по умолчанию):* правами доступа к первой области доступа членов класса и - типа наследования: 
для структур – public, для классов – private



### Действия над объектами классов

▪ присваивать объекты одного и того же класса (при этом производится почленное копирование членов данных), 
▪ получать адрес объекта с помощью операции &, 
▪ передавать объект в качестве формального параметра в функцию
▪ возвращать объект в качестве результата работы функции.
▪ осуществлять доступ к элементам объекта с помощью операции '.', а если используется указатель на объект, то с помощью операции '->'. 
▪ вызывать методы класса, определяющие поведение объекта.

```
class A { 
	int a;
	public: 
		void set_a (int n); 
		int get_a ( ) const { return a; }  
}; 

void A::set_a (int n) { 
	a = n; 
} 

int main () { 
	A obj1, obj2; obj1.set_a(5); 
	obj2.set_a(10); 
	cout << obj1.get_a ( ) << '\n';
	cout << obj2.get_a ( ) << endl; return 0; 
}
```


### АТД( абстрактный тип данных) 

***АТД*** называют тип данных с полностью скрытой (инкапсулированной) структурой, а работа с переменными такого типа происходит только через специальные, предназначенные для этого функции


### Указатель this

Иногда для реализации того или иного метода возникает необходимость иметь указатель на «свой» объект, от имени которого производится вызов данного метода.

В C++ введено ключевое слово this, обозначающее «указатель на себя», которое можно трактовать как неявный параметр любого метода класса:
```
<имя класса> * const this; 
*this – сам объект.
```

### Конструктор

Конструктор - метод класса, который - имеет имя, в точности совпадающее с именем самого класса:
- не имеет типа возвращаемого значения; 
- всегда вызывается при создании объекта (сразу после отведения памяти под объект в соответствии с его описанием).

### Деструктор

Деструктор – метод класса, который - имеет имя, совпадающее с именем класса, перед первым символом которого приписывается символ ~ ; 
- не имеет типа возвращаемого значения и параметров; 
- всегда вызывается при уничтожении объекта (перед освобождением памяти, отведенной под объект).

```
class A { ......
	public:
		A ( ); // конструктор умолчания
		A (A & y); // A (const A & y); конструктор копирования (КК)
[explicit] A (int x); // конструктор преобразования; explicit запрещает
					  // компилятору неявное преобразование int в А
		A (int x, int y);
		A (int x = 0, int y = 0); // заменяет 1-ый, 3-ий и 4-ый
		~A (); // деструктор
};

nt main() {
    A a1; // Вызов конструктора умолчания

    A a2(a1); // Вызов конструктора копирования

    A a3(10); // Вызов конструктора преобразования (явный)

	A a4(5, 15); // Вызов конструктора с двумя параметрами
    
    A a5 = static_cast<A>(20); // Явный вызов конструктора преобразования (через static_cast)

    return 0;
}
```



### Правила автоматической генерации специальных методов класса

❖ Если в классе явно не описан никакой конструктор, то конструктор умолчания генерируется автоматически с пустым телом в **public** области.

❖ Если в классе явно не описан конструктор копирования, то он всегда генерируется автоматически в **public** области с телом, реализующим почленное копирование значений полей-данных параметра конструктора в значения соответствующих полей-данных создаваемого объекта 

❖ Если в классе явно не описан деструктор, то он всегда генерируется автоматически с пустым телом в public области.

### Композиция/Агрегация объектов

Композиция (composition) — это сильная агрегация «часть-целое», где части не могут существовать без целого. Если объект, содержащий другую часть (состоящие из более мелких объектов), удаляется, то и все его части также удаляются. Композиция подразумевает, что жизненный цикл части управляется целым. 

```
class Engine {
public:
    Engine() {
        std::cout << "Engine created." << std::endl;
    }
    ~Engine() {
        std::cout << "Engine destroyed." << std::endl;
    }
};

class Car {
private:
    Engine engine; 

public:
    Car() {
        std::cout << "Car created." << std::endl;
    }
    ~Car() {
        std::cout << "Car destroyed." << std::endl;
    }
};

int main() {
    Car myCar; // Создается объект Car, а так же объект Engine
    return 0;
}
```


Агрегация (aggregation) — это более слабое отношение частям, чем в композиции. Части могут существовать независимо от целого. Это означает, что если объект, который содержит другую часть, удаляется, то части могут продолжать существовать.

```
class Driver {
public:
    Driver() {
        std::cout << "Driver created." << std::endl;
    }

    ~Driver() {
        std::cout << "Driver destroyed." << std::endl;
    }
};

class Car {
private:
    Driver* driver; // Агрегация: Driver существует отдельно от Car

public:
    Car(Driver* drv) : driver(drv) {
        std::cout << "Car created." << std::endl;
    }

    ~Car() {
        std::cout << "Car destroyed." << std::endl;
    }
};

int main() {
    Driver* myDriver = new Driver(); // Создаем объект Driver
    Car myCar(myDriver); // Передаем указатель на Driver в Car
    delete myDriver; // Уничтожаем Driver, Car все еще существует
    return 0;
}

```

Жизненный цикл:
  - Композиция: части уничтожаются вместе с целым.
  - Агрегация: части могут существовать независимо от целого.
  
Сила связи:
  - Композиция: сильная связь.
  - Агрегация: слабая связь.


```
string & string :: operator = (const string & a) {
```


### const и & в функции класса

`void drive(const Driver& driver) const;

1. Первый const: указывает, что объект driver, который передается в метод, не может быть изменен внутри этого метода. Это означает, что вы не можете изменить состояние или члены объекта driver в теле метода.

2. const в конце: указывает, что сам метод drive не изменяет состояние объекта (то есть объекта, для которого вызывается данный метод). Вы не можете изменять члены (переменные) класса, к которому принадлежит этот метод.

### Временные объекты

**Временные объекты**  — это объекты, которые создаются «на лету», обычно в результате выражений, а затем автоматически уничтожаются, когда они больше не нужны. Они могут возникать в различных контекстах, например, при создании временных значений, которые используются для инициализации другой переменной или передаются в функции. 

```
class Point {
public:
   int x, y;
   Point(int x, int y) : x(x), y(y) {}
   Point operator+(const Point& p) {
	   return Point(x + p.x, y + p.y); // Возвращаем временный объект
   }
};

Point p1(1, 2);
Point p2(3, 4);
Point p3 = p1 + p2; // Создается временный объект, который затем присваивается p3


```

```
Point createPoint() {
   return Point(10, 20); // Создается временный объект
}

Point p = createPoint(); // Временный объект передается p
```

```
void printPoint(const Point& p) {
   std::cout << "(" << p.x << ", " << p.y << ")\n";
}

printPoint(Point(5, 6)); // Создается временный объект для передачи
```


При использовании временных объектов важно помнить о следующем:

НО! Если инициализировать ссылку на константу ВО-ом (в частности, передавать ВО в качестве фактического параметра для формального параметра–ссылки на константу), время его жизни продлевается до конца жизни соответствующей ссылочной переменной.

НЕЛЬЗЯ инициализировать неконстантную ссылку ВО-ом (в частности, неконстантные ссылки – формальные параметры).


