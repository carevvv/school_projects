
## Умные указатели

Умный указатель - спасает нас, от того, чтобы следить за тем, чтобы каждому new[] соответствовал delete[].
Перекладываем ему ответственность за жизнь объекта, то если мы потеряем указатель, то у него автоматически вызовется деструктор.

```
#include <iostream>
#include <memory> // Необходимо для использования умных указателей

class MyClass {
public:
    MyClass() { std::cout << "Конструктор MyClass" << std::endl; }
    ~MyClass() { std::cout << "Деструктор MyClass" << std::endl; }

    void SayHello() { std::cout << "Привет от MyClass!" << std::endl; }
};

int main() {
    {
        std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>(); // Создаем уникальный умный указатель

        ptr->SayHello(); // Используем объект через умный указатель
    } // Память автоматически освобождается при выходе из области видимости

    std::cout << "Программа завершена" << std::endl;
    return 0;
}
```


Библиотеки:

```
#include <memory> // Необходимо для использования умных указателей

std::unique_ptr<T>; - только один указатель на данный объект!
std::shared_ptr<T>; - бесконечно указателей на один объект;
std::weak_ptr<T>; - при удалении всех shared_pointer - владение объектов прекращается и он уничтожается. 

// weak_pointer - может указаться только от другого weak_pointer или shared_pointer. Нужен только для "подглдывания" за объектом, только для того, чтобы посмотреть на объект или узнать удален ли он.

```


# Singleton

**Singleton** — это шаблон проектирования, который гарантирует, что у класса будет только один объект, и предоставляет к нему глобальную точку доступа. В C++ это особенно полезно для управления ресурсами или предоставления доступа к единому объекту, который используется во всей программе

### Основные аспекты Singleton:

1. Ограничение создания экземпляров: Singleton гарантирует, что у класса будет только один объект.
2. Глобальная точка доступа: Он предоставляет стандартный метод для получения доступа к объекту класса(можно получить из любой точки программы).
3. Используется для управления ресурсами.
4. Обеспечивает наличие единственного источника конфигураций или настроек, что уменьшает возможность расхождений.


```
class Singleton {
private:
    static Singleton* instance;

    // Конструктор должен быть скрытым
    Singleton() {}

public:
    // Статическая функция для получения единственного экземпляра
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    // Другие функции-члены
    void someFunction() {
        // Реализация функции
    }
};

// Инициализация статического члена
Singleton* Singleton::instance = nullptr;
```

